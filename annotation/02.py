# Аннотации функций введены в PEP-3107 для обеспечения стандартного способа связывания метаданных с аргументами функции и возвращаемым значением. 
# В функциях мы можем аннотировать аргументы и возвращаемое значение:
def repeater(s: str, n: int) -> str:
    return s * n
# Аннотация для аргумента определяется через двоеточие после его имени.
# имя_аргумента: аннотация
# Аннотация, определяющая тип возвращаемого функцией значения, указывается после ее имени с использованием символов ->
# def имя_функции() -> тип
# Для лямбд аннотации не поддерживаются.
# Аннотации не влияют на выполнение функции. Если вызвать foo() дважды: один раз с аргументами int и один раз с строковыми аргументами, в обоих случаях foo() работает, а аннотации просто игнорируются.

print(repeater("str", 20))
print(repeater(29, 20))

# Аргументы по умолчанию указываются после аннотации:
def foo(x: "an argument that defaults to 5" = 5):
    print(x)
# Объект функции имеет атрибут 'annotations', что сопоставляет каждое имя аргумента с его аннотацией. Аннотации возвращаемого значения сопоставляются с ключом return, который не может конфликтовать с любым именем аргумента. Можно передать аргумент ключевого слова с именем return в функцию:

def bar(*args, **kwargs: 'the keyword arguments dict'):
    print(kwargs['return'])

foo()

d = {'return': 4}
bar(**d)

# Аннотации - это просто атрибут dict функции: type(foo.__annotations__) # dict
# Это означает, что вы можете изменять их на лету во время работы программы. Предположим, вы хотите узнать, используется ли значение аргумента по умолчанию для аргумента по умолчанию. Всякий раз, когда функция вызывается со значением по умолчанию, вы можете увеличить значение аннотации. Или, может быть, вы хотите суммировать все возвращаемые значения. Динамический аспект можно сделать внутри самой функции или декоратора.

def add(a, b) -> 0:
    result = a + b
    add.__annotations__['return'] += result
    return result

print(add.__annotations__['return'])
add(3, 4)
print(add.__annotations__['return'])
add(5, 5)
print(add.__annotations__['return'])

def foot(a, b: 'annotating b', c: int) -> float:
    print(a + b + c)
print(foot.__annotations__) # {'c': <class 'int'>, 'b': 'annotating b', 'return': <class 'float'>}

# Если вы аннотируете функцию с массивом аргументов и / или массивом аргументов аргументов, то, вы не можете аннотировать отдельные аргументы.
def foom(*args: 'list of unnamed arguments', **kwargs: 'dict of named arguments'):
    print(args, kwargs)
print(foom.__annotations__) # {'args': 'list of unnamed arguments', 'kwargs': 'dict of named arguments'}
