# В Python можно выполнить сортировку списка на месте с помощью метода sort():
a = [10,3,4,1,9]
a.sort()
print("Сортировка списка: ", a) # [1, 3, 4, 9, 10]

# встроенная функция sorted() не изменяет последовательность, а возвращает новую отсортированную.
print("встроенная функция sorted() возвращает новую отсортированную: ", sorted(a, reverse=True))
print("встроенная функция sorted() возвращает новую отсортированную: ", sorted("qwerty"))

# Сортировка по произвольным элементам вложенных списков
# Если элементы списка сами представляют собой списки, т. е. являются вложенными списками, то сортировка будет происходить по первым элементам вложенных списков, то есть в случае матрицы по первому столбцу:

a = [[12,101],[2,200],[18,99]]
a.sort()

print("Сортировка по произвольным элементам вложенных списков", a) # [[2, 200], [12, 101], [18, 99]]
# Отсортировать список идентификаторов, представленных в виде строк. Каждый идентификатор представляет собой объединение идентификатора строки и числа.
ids = ['id1', 'id2', 'id30', 'id3', 'id22', 'id100']
# При сортировке этого списка с помощью встроенной функции sorted() по умолчанию используется лексикографический порядок, поскольку элементы в списке являются строками.
print(sorted(ids)) # Lexicographic sort ['id1', 'id100', 'id2', 'id22', 'id3', 'id30']
# Выполнить сортировку так, чтобы сортировка использовала число, связанное с идентификатором:

# print(sorted_ids) # ['id1', 'id2', 'id3', 'id22', 'id30', 'id100']

#  Многие функции (особенно чистые функции) просто берут объект и возвращают какой-то объект. Встроенная функция изменяет существующий объект, это называется побочным эффектом. 
# list.sort() сортирует список на месте (это означает , что он изменяет исходный список) и возвращает значение None . Следовательно, это не будет работать так, как со списковыми включениями:
[x.sort() for x in [[2, 1], [4, 3], [0, 1]]]
# Out: [None, None, None]
# Вместо sorted() возвращает отсортированный list , а не сортировку на месте:
[sorted(x) for x in [[2, 1], [4, 3], [0, 1]]]
# Out: [[1, 2], [3, 4], [0, 1]]

 
# Допускается использование включений для побочных эффектов, таких как ввод-вывод или встроенных функций. Тем не менее лучше использовать цикл for. Так это работает в Python 3:

[print(x) for x in (1, 2, 3)] 
# Вместо этого используйте:

for x in (1, 2, 3):
    print(x)

# В некоторых ситуациях функции побочных эффектов подходят для списковых включений. У random.randrange() есть побочный эффект изменения состояния генератора случайных чисел, но он также возвращает интересное значение. Кроме того, next() может вызываться на итераторе.
# Следующий генератор случайных значений не является чистым, но имеет смысл, поскольку генератор случайных значений сбрасывается каждый раз, когда вычисляется выражение:
from random import randrange
[randrange(1, 7) for r in range(10)]
# Out:[2, 3, 2, 1, 1, 5, 2, 4, 3, 5]

