# Более полное описание шаблона для создания представлений списка 
# добавляет поддержку необязательных условных выражений. 
# Наиболее распространенный способ добавить условную логику к list comprehension 
# — добавить условное выражение в конец выражения:
# new_list = [expression for member in iterable (if conditional)]
# Здесь наше условное утверждение предшествует закрывающей скобке.
# Условные выражения позволяют отфильтровывать нежелательные значения, без вызова filter():

# Условия можно внедрять и в списковые включения. 

# Состояние проверено на 1-й петле
[x + y for x in [1, 2, 3] if x > 2 for y in [3, 4, 5]]

# Состояние проверено на 2-й петле
[x + y for x in [1, 2, 3] for y in [3, 4, 5] if x > 2] 

# Условие проверено, если зацикленные числа нечётные
[x for x in range(10) if x % 2 == 0]   


# новый_список = [«операция» for «элемент списка» in «список» if «условие»]
# Такой вариант использования условий позволяет отсечь часть элементов итератора. 
# Новый список будет короче первоначального. 
# По сути, к той же конструкции, которая приведена выше, добавляется условие if.
# Получение списка из чисел, которые делятся на 11 без остатка
numbers = [121, 544, 111, 99, 77]  # Исходный список чисел
number11 = [num for num in numbers if num % 11 == 0]  
# Выбираем только те числа, которые делятся на 11
print(number11)  # [121, 99, 77]

# В результате мы получаем только те элементы, 
# которые делятся на 11 без остатка.  
# Условие может быть только одно 
# (т. е. невозможно использовать elif, else или другие if, как в циклах).

[x for x in (1, 2, 3) if x % 2 == 0] # списковое включение с фильтром

[n for n in range(1, 10000) if n % 2 == 0] # Чётные числа от 2 до 9998 включительно:

sentence = 'the rocket came back from mars'
vowels = [i for i in sentence if i in 'aeiou']
print(vowels)
# ['e', 'o', 'e', 'a', 'e', 'a', 'o', 'a']
# В этом блоке кода условный оператор отфильтровывает любые символы в sentence, 
# которые не являются гласными.

# Условие может содержать любое допустимое выражение. 
# Если вам нужен более сложный фильтр, вы можете переместить условную логику 
# в отдельную функцию:

sentence = 'The rocket, who was named Ted, came back \
... from Mars because he missed his friends.'
def is_consonant(letter):
    vowels = 'aeiou'
    return letter.isalpha() and letter.lower() not in vowels

consonants = [i for i in sentence if is_consonant(i)]
# ['T', 'h', 'r', 'c', 'k', 't', 'w', 'h', 'w', 's', 'n', 'm', 'd', \
# 'T', 'd', 'c', 'm', 'b', 'c', 'k', 'f', 'r', 'm', 'M', 'r', 's', 'b', \
# 'c', 's', 'h', 'm', 's', 's', 'd', 'h', 's', 'f', 'r', 'n', 'd', 's']
# Здесь мы создаем сложный фильтр is_consonant() 
# и передаете эту функцию как условный оператор для нашего представления списка. 
# значение элемента i также передается в качестве аргумента нашей функции.

# Если требуется не фильтрация данных по какому-то критерию, 
# а изменение типа операции над элементами последовательности, 
# условия могут использоваться в начале генератора списков.
# Общий вид конструкции: 
# новый_список = [«операция» if «условие» for «элемент списка» in «список»]
# В отличие от предыдущего типа условий, здесь оно может дополняться вариантом 
# else (но elif и тут невозможен).


# Можно комбинировать тройные выражения и if условия. 
# Тернарный оператор работает с отфильтрованным результатом:

[x if x > 2 else '*' for x in range(10) if x % 2 == 0]
# Out: ['*', '*', 4, 6, 8] 

# То же самое не могло быть достигнуто только одним троичным оператором:
[x if (x > 2 and x % 2 == 0) else '*' for x in range(10)]
# Out:['*', '*', '*', '*', 4, '*', 6, '*', 8, '*']
