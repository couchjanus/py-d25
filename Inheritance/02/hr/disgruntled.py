# disgruntled.py

# Когда вы наследуете один класс от другого, производный класс наследует оба:
# Интерфейс базового класса: производный класс наследует все методы, свойства и атрибуты базового класса.
# Реализация базового класса: производный класс наследует код, который реализует интерфейс класса.

# В большинстве случаев вы захотите наследовать реализацию класса, 
# но вам нужно реализовать несколько интерфейсов, 
# чтобы ваши объекты могли использоваться в разных ситуациях.
# Современные языки программирования разработаны с учетом этой базовой концепции. 
# Они позволяют вам наследовать от одного класса, но вы можете реализовать несколько интерфейсов.

# В Python не нужно явно объявлять интерфейс. 
# Любой объект, который реализует желаемый интерфейс, может использоваться вместо другого объекта. 
# Это известно как утиная типизация (duck typing). 
# Утиная типизация обычно объясняется так «если что то ведет себя как утка, то это утка».

# Чтобы проиллюстрировать это, мы добавим класс DisgruntledEmployee в приведенный выше пример, 
# который не является производным от Employee:

class DisgruntledEmployee:
    def __init__(self, id, name):
        self.id = id
        self.name = name
    def calculate_payroll(self):
        return 1000000

# Класс DisgruntledEmployee не является производным от Employee, 
# но предоставляет тот же интерфейс, который требуется PayrollSystem. 
# PayrollSystem.calculate_payroll() требует список объектов, которые реализуют следующий интерфейс:
#     Свойство id или атрибут, который возвращает идентификатор сотрудника
#     Свойство name или атрибут, представляющий имя сотрудника
#     Метод .calculate_payroll(), который не принимает никаких параметров и возвращает сумму заработной платы для обработки

# Все эти требования выполняются классом DisgruntledEmployee, 
# поэтому PayrollSystem все еще может рассчитать свою заработную плату.
