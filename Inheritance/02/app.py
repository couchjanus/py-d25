# Создание иерархии классов
import hr.prs as prs

# Абстрактные базовые классы в Python

# Проверим, что объекты типа Employee не могут быть созданы:
# employee = prs.Employee(1, 'abstract')
# Traceback (most recent call last):
#   File "/home/janus/work/py-g25/Inheritance/02/app.py", line 9, in <module>
#     employee = hr.Employee(1, 'abstract')
# TypeError: Can't instantiate abstract class Employee with abstract method calculate_payroll

# Результат показывает, что класс не может быть создан, 
# поскольку он содержит абстрактный метод calculate_payroll(). 

# Производные классы должны переопределять метод, чтобы разрешить создание объектов их типа.

# Когда наследуется один класс от другого, производный класс наследует оба:
# Интерфейс базового класса: производный класс наследует все методы, свойства и атрибуты базового класса.
# Реализация базового класса: производный класс наследует код, который реализует интерфейс класса.

# При наследовании реализации класса нужно реализовать несколько интерфейсов, 
# чтобы объекты могли использоваться в разных ситуациях.
# Современные языки программирования разработаны с учетом этой базовой концепции. 
# Они позволяют наследовать от одного класса, но можно реализовать несколько интерфейсов.

# В Python не нужно явно объявлять интерфейс. 
# Любой объект, который реализует желаемый интерфейс, может использоваться вместо другого объекта. 
# Это известно как утиная типизация (duck typing). 
# Утиная типизация обычно объясняется так «если что то ведет себя как утка, то это утка».

# Добавим класс DisgruntledEmployee, 

# Класс DisgruntledEmployee не является производным от Employee, 
# но предоставляет тот же интерфейс, который требуется Payroll. 
# Payroll.calculate_payroll() требует список объектов, которые реализуют следующий интерфейс:
# - Свойство id или атрибут, который возвращает идентификатор сотрудника
# - Свойство name или атрибут, представляющий имя сотрудника
# - Метод .calculate_payroll() не принимает никаких параметров и возвращает сумму заработной платы

# Для использования класса DisgruntledEmployee:

import hr.disgruntled

# создаем три объекта employee, по одному для каждого из производных классов. 

salary_employee = prs.SalaryEmployee(1, 'John Smith', 1500)
hourly_employee = prs.HourlyEmployee(2, 'Jane Doe', 40, 15)
commission_employee = prs.CommissionEmployee(3, 'Kevin Bacon', 1000, 250)
# создаем объект DisgruntledEmployee и добавляем его в список, обрабатываемый Payroll. 
disgruntled_employee = hr.disgruntled.DisgruntledEmployee(20000, 'Anonymous')

payroll_system = prs.Payroll()

payroll_system.calculate_payroll([
    salary_employee,
    hourly_employee,
    commission_employee,
    disgruntled_employee
])


# Payroll по-прежнему может обрабатывать новый объект, 
# поскольку он соответствует требуемому интерфейсу.

# Используйте наследование для повторного использования всей реализации: 
# производные классы должны использовать большую часть своей реализации базового класса.

# Реализуйте интерфейс для повторного использования только небольшой части реализации: 
# если вы хотите, чтобы ваш класс повторно использовался только небольшой частью 
# (например один определенный метод).
