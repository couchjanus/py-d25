# Язык определения данных (Data Definition Language) предназначен для создания, изменения и удаления объектов базы данных. Основными объектами реляционной базы данных являются таблицы. Таблицы бывают базовые (постоянные) и временные. 
# Временные таблицы существуют в течение сеанса пользователя, в котором он их создал. Если в этом сеансе таблицы не удаляются явно, то они будут удалены автоматически по завершении сеанса. 
# Базовые таблицы предназначены для долговременного хранения информации в базе данных.
# Команды языка определения данных DDL - это подмножество SQL, используемое для определения и модификации различных структур данных.  Команды CREATE (создание), ALTER (модификация) и DROP (удаление) предназначены для различных типов объектов баз данных (таблиц, представлений, процедур, триггеров, табличных областей, пользователей и др.). Существует множество команд DDL, например, CREATE TABLE, CREATE VIEW, CREATE PROCEDURE, CREATE TRIGGER, CREATE USER, CREATE ROLE и т.д.

# Запросы в SQLite очень похожи на те, которые вы используете в других базах данных, таких как MySQL или Postgres. Мы просто используем обычный синтаксис SQL для выполнения запросов, после чего объект cursor выполняет SQL. 
# Базовые таблицы создаются оператором CREATE TABLE:

# 	CREATE TABLE <имя таблицы>(<список спецификаций столбцов и ограничений>);

# Спецификация столбца включает имя столбца и тип данных значений, которые могут находиться в этом столбце. Кроме того, в спецификации столбца могут быть заданы некоторые ограничения. 

# SQLite поддерживает динамическое типизирование данных. Возможные типы значений: INTEGER, REAL, TEXT и BLOB. Так же поддерживается специальное значение NULL.
# Размеры значений типа TEXT и BLOB не ограничены ничем, кроме константы SQLITE_MAX_LENGTH в исходниках sqlite, равной миллиарду.
# Каждое значение в любом поле любой записи может быть любого из этих типов, независимо от типа, указанного при объявлении полей таблицы. Указанный при объявлении поля тип хранится для справки в его исходном написании, и используется в качестве основы для выбора предпочтений (type affinity) при выполнении неявных преобразований типов на основании похожести этого названия типа на что-либо. В алгоритм зашит обширный перечень практикуемых в других СУБД вариантов названий типов данных. Если безопасного преобразования записываемого значения в предпочитаемый тип не получается, SQLite записывает значение в его исходном виде. Для получения значений из базы есть ряд функций для каждого из типов, и если тип хранимого значения не соответствует запрашиваемому, оно тоже, по возможности, преобразуется.

# Во время компиляции библиотеки SQLite устанавливаются следующие ограничения, которые можно, при острой необходимости, увеличивать:
# Максимальная длина строки или BLOB-поля (SQLITE_MAX_LENGTH): 1 000 000 000
# Максимальное количество колонок ( SQLITE_MAX_COLUMN): 2 000    
# Максимальная длина SQL-выражения (SQLITE_MAX_SQL_LENGTH): 1 000 000 000     
# Максимальное количество таблиц в выражениях с JOIN: 64     
# Максимальная глубина дерева выражений (SQLITE_MAX_EXPR_DEPTH): 1 000     
# Максимальное количество аргументов функции (SQLITE_MAX_FUNCTION_ARG): 127     
# Максимальное количество термов в объединённом выражении с SELECT (SQLITE_MAX_COMPOUND_SELECT):  500     
# Максимальная длина шаблона как аргумента операторов LIKE или GLOB (SQLITE_MAX_LIKE_PATTERN_LENGTH): 50 000     
# Максимальное количество символов-заменителей в одном SQL-выражении (SQLITE_MAX_VARIABLE_NUMBER): 999    
# Максимальная глубина рекурсии триггеров (SQLITE_MAX_TRIGGER_DEPTH): 1 000     
# Максимальное количество присоединённых баз (SQLITE_MAX_ATTACHED): 10     
# Максимальный размер страницы базы данных (SQLITE_MAX_PAGE_SIZE):  65 536     
# Максимальное количество страниц в файле базы данных (SQLITE_MAX_PAGE_COUNT):  1 073 741 823     

# Максимальный размер файла базы данных составляет примерно 140 ТБ.
# Некоторые ограничения можно менять в сторону уменьшения во время исполнения программы при помощи задания категории и соответствующего значения функции sqlite3_limit():
# int sqlite3_limit(sqlite3*, int id, int newVal)

# Следующим шагом является создание схемы для определения таблиц в базе данных. Создавая таблицы, мы создаем реляционную модель предметной области.
# Таблица project

# Колонка		Тип колонки	Описание

# name		text 			Название проекта
# description 	text 			Длинное описание проекта
# deadline 		date 			Срок выполнения для всего проекта

# todo_schema.sql:


# -- Schema for to-do application.
# -- Projects are high-level activities made up of tasks
# create table project (
#    name        text primary key,
#    description text,
#    deadline    date
# );


# Таблица task

# Колонка		Тип колонки	Описание
# id     			number     	Уникальный идентификатор задачи
# priority     		integer     		Числовой приоритет, более низкий более важный
# details     		text     		Полная информация о задании
# status     		text     		Статус задачи (новый, выполненный, отмененный).
# deadline     	date     		Дата окончания срока выполнения этой задачи
# completed_on   date     		Дата завершения - когда задание было выполнено.
# project     		text     		Название проекта для этой задачи.

# -- Tasks are steps that can be taken to complete a project
# create table task (
#    id           integer primary key autoincrement not null,
#    priority     integer default 1,
#    details      text,
#    status       text,
#    deadline     date,
#    completed_on date,
#    project      text not null references project(name)
# );

# С использованием ключевого слова with, код является более компактным, интерпретатор Python обеспечивает лучшую обработку ошибок и автоматически освобождает ресурсы.

# with open(schema_filename, 'rt') as f:
# Метод executetescript() использоваться для запуска инструкций DDL. В качестве аргумента передается скрипт на языке SQL, который может включать несколько запросов, каждый из которых заканчивается точкой с запятой.
# Вызываем метод executetescript() для создания схемы.

#        with open(schema_filename, 'rt') as f:
#            schema = f.read()
#        conn.executescript(schema)

import os
import sqlite3

db_filename = 'todo/todo.db'
schema_filename = 'todo/todo_schema.sql'

# Выполняем поиск файла базы данных перед его открытием с помощью connect()
db_is_new = not os.path.exists(db_filename)

with sqlite3.connect(db_filename) as conn:
   if db_is_new:
       print('Creating schema')
       with open(schema_filename, 'rt') as f:
           schema = f.read()
       conn.executescript(schema)
       print('Schema Created Successfully')
   else:
       print('Database exists, assume schema does, too.')
