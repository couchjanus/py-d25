# flush.file.py

# file.flush ()
# может быть недоступно для некоторых файловых объектов.

# Обычно используются два уровня буферизации:
# Внутренние буферы
# Буферы операционной системы

# Внутренние буферы - это буферы, созданные исполняемой средой/библиотекой/языком, 
# и предназначены для ускорения работы, 
# избегая системных вызовов для каждой записи. 
# Вместо этого, когда идет запись файл-объекта, 
# он записывается его в буфер, 
# а когда буфер заполняется, 
# данные записываются в фактический файл с помощью системных вызовов.

# Однако из-за реализации буферизации операционной системы 
# данные могут копируются из буфера среды выполнения, 
# в буфер операционной системой.

# Методы flush и fsync файлового объекта помогают выполнить синхронизацию записи.

# Метод flush просто запишет любые данные, 
# которые задерживаются в программном буфере в фактический файла. 
# Обычно это означает, что данные будут скопированы из буфера программы 
# в буфер операционной системы.
# Если в другом процессе открыт тот же файл для чтения, 
# он сможет получить доступ к данным, 
# которые вы только что сбросили в файл. 
# Однако это не обязательно означает, что он "постоянно" хранится на диске.

# Для этого нужно вызвать метод os.fsync, 
# который обеспечивает синхронизацию всех буферов операционной системы 
# с устройствами хранения, для которых они предназначены, 
# другими словами, этот метод будет копировать данные 
# из буферов операционной системы на диск.

# Open a file
fo = open("foo.txt", "wb")
print ("Name of the file: ", fo.name)

# Here it does nothing, but you can call it with read operation.
fo.flush()

# Close opened file
fo.close()
