# Когда мы создаем переменную в блоке кода, она будет разрешена при помощи ближайшей области видимости. 
# Группирование всех этих областей известно как среда блоков кода. 
# Все назначения выполняются в локальной области по умолчанию. 
x = 10
def func(a, b):
   print(x)
   print(z)
# func(1, 2)
# z не определена, или находится вне области видимости, так что когда мы вызываем функцию, мы получаем ошибку NameError.

def my_funci(a, b):
   i = 2
   print(x)

x = 10
my_funci(1, 2)
# print(i)

# Переменная i определена только внутри функции, так что при запуске кода мы получаем ошибку NameError.

# Имеем две переменные х. 
# Переменная х внутри my_func имеет локальную область видимости функции и переопределяет переменную х вне функции. 

def my_func(a, b):
   x = 5
   print(x)
x = 10
# Когда мы вызываем функцию my_func, в выдаче мы видим 5. 
my_func(1, 2)
# Когда функция завершает работу, локальная область функции my_func очищается, а область модуля все еще содержит х=10. 
print(x)

# Python содержит оператор global. Оператор global объявляет переменную доступной для блока кода, следующим за оператором. 

def my_funcg(a, b):
   global x
   print(x)
   x = 5
   print(x)
x = 10
my_funcg(1, 2)
print(x)

# В Python 3 было добавлено новое ключевое слово под названием nonlocal. С его помощью мы можем добавлять переопределение области во внутреннюю область. 
def counter():
   num = 0
   def incrementer():
       nonlocal num
       num += 1
       return num
   return incrementer

# Тип такой функции называется closure. Такая функция является блоком кода, который «закрывает» переменные nonlocal. Обычно, nonlocal позволяет назначать переменные во внешней области, но не в глобальной.

c = counter()
print(c)
print(c())
print(c())
print(c())

# Анонимные (лямбда) функции - это однострочные функции, которые используются в случаях, когда вам не нужно повторно использовать функцию в программе. Python разрешает создание анонимных функций во время выполнения, используя конструкцию lambda:
# lambda argument: manipulate(argument)
# Функция тождества (identity function), функция, которая возвращает свой аргумент, выражается стандартным определением функции Python с использованием ключевого слова def следующим образом:

# identity() принимает аргумент x и возвращает его при вызове.
def identity(x):
   return x

# лямбда-конструкция: lambda x: x
# Ключевое слово: lambda
# Связанная переменная: x связанная переменная является аргументом лямбда-функции.
# Тело: x
# Сокращение – это стратегия лямбда-исчисления: lambda x: x + 1

(lambda x: x + 1)(2)  # аргументы функции заключаются в круглые скобки

# Свободная переменная не связана и может указываться в теле выражения. 
# Свободная переменная может быть константой или переменной, определенной в прилагаемой области действия функции.
# Поскольку лямбда-функция является выражением, она может быть именована:

add_one = lambda x: x + 1
add_one(2) # 3

# лямбда-функция эквивалентна:
def add_one(x):
   return x + 1

# Аргументы lambda функции не имеют круглых скобок вокруг них. 
# Функции с несколькими аргументами в лямбда-выражениях перечисляют аргументы, разделяя их запятой (,), но не заключая их в круглые скобки:

# Лямбда-функция full_name, принимает два аргумента и возвращает строку, интерполирующую два параметра:

full_name = lambda first, last: f'Full name: {first.title()} {last.title()}'
print(full_name('guido', 'van rossum')) # 'Full name: Guido Van Rossum'

# передача аргументов в лямбда-выражения:

(lambda x, y, z: x + y + z)(1, 2, 3) # 6
(lambda x, y, z=3: x + y + z)(1, 2) # 6
(lambda x, y, z=3: x + y + z)(1, y=2) # 6


# Находим квадратный корень
import math

def sqroot(x):
   return math.sqrt(x)

square_rt = lambda x: math.sqrt(x)

print(sqroot(49)) # 7.0
print(square_rt(64)) # 8.0

# В отличие от обычной функции, лямбда-функция представляет собой одно выражение. Хотя в теле лямбды вы можете разбить выражение на несколько строк, используя скобки или многострочную строку, оно остается одним выражением:

(lambda x:
  (x % 2 and 'odd' or 'even'))(3) # 'odd'

# Пример возвращает строку «odd», если лямбда-аргумент нечетный, и «even», когда аргумент четный. Он распространяется на две строки, поскольку содержится в скобках, но остается одним выражением.


# Определение lambda функции не включает оператор return - эта конструкция всегда содержит выражении, результат которого возвращается. 
# Функция make_inrementor создает анонимную функцию на лету и возвращает ее. Возвращенная функция увеличивает свой аргумент на значение, которое было определено когда она была создана.

def make_incrementor (n): return lambda x: x + n
f = make_incrementor(2)
g = make_incrementor(6)
print(f(42), g(42)) # 44 48
print(make_incrementor(22)(33)) # 55

# calc.py
   # if operator == "+":
   #     r = lambda a, b: a + b
   # elif operator == '-':
   #     r = lambda a, b: a - b
   # elif operator == "*":
   #     r = lambda a, b: a * b
   # elif operator == "%" and b !=0:
   #     r = lambda a, b: a % b
   # elif operator == "/" and b !=0:
   #     r = lambda a, b: a / b

# calc1.py

# Используем dictionary:
lambda_ops = {
   "+": (lambda x,y: x+y),
   "-": (lambda x,y: x-y),
   "*": (lambda x,y: x*y),
   "/": (lambda x,y: x/y),
   "//": (lambda x,y: x//y),
   "%": (lambda x,y: x%y),
}
# ... вызываем
print(lambda_ops['+'] (1,2))

# или, если орерацию вводит пользователь:

# if operator in lambda_ops:
#    val = lambda_ops[operator](x, y)
# else:
#    pass # something about wrong operator

def result(a, b, operator):
   lambda_ops = {
       "+": (lambda x,y: x+y),
       "-": (lambda x,y: x-y),
       "*": (lambda x,y: x*y),
       "/": (lambda x,y: x/y),
       "//": (lambda x,y: x//y),
       "%": (lambda x,y: x%y),
   }

   r = False
   error = ''
   if operator in lambda_ops:
       if (operator == "/" or operator == "//" or operator == "%" ) and b==0:
           error = "Oops, division or modulo by zero"
       else:
           r = lambda_ops[operator](a, b)
   else:
       error = "Use either + - * / or % next time"
   return r, error
