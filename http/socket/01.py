# 01.py
# Суть TCP-соединения: одна программа устанавливает соединение с другой, и они обмениваются данными, причем их потери не происходит.
# После завершения работы соединение должно быть закрыто.
# API-вызовы, которые сервер делает для настройки слушающего сокета:
# socket()
# bind()
# listen()
# accept()
# srv01_socket.py
import socket # Для работы с сокетами нужно импортировать модуль socket
# Создадим объект сокета с помощью socket.socket()
# Для инициализации сокета  существует одноименный системный вызов socket().
server_sock = socket.socket() # создать сокет
# Аргументы, передаваемые функции socket(), определяют семейство адресов и тип сокета.
# AF_INET - это семейство интернет-адресов для IPv4.
# SOCK_STREAM - это тип сокета для TCP, протокола, который будет использоваться для передачи сообщений.
print(socket.AF_INET)  # AddressFamily.AF_INET
print(socket.SOCK_STREAM)  # SocketKind.SOCK_STREAM
# Определим тип сокета как socket.SOCK_STREAM. По умолчанию используется протокол управления передачей (TCP).
server_sock = socket.socket(
   socket.AF_INET,      # задамем семейство протоколов 'Интернет' (INET)
   socket.SOCK_STREAM,  # задаем тип передачи данных 'потоковый' (TCP)
   proto=0)             # выбираем протокол 'по умолчанию' для TCP, т.е. IP

# доступ к целочисленному файловому дескриптору можно получить с помощью:
print(server_sock.fileno())  # int
print(server_sock.proto)  # 0
# Для создания сервера нужно связать сокет с одним или всеми из имеющихся у компьютера хостов (IP-адресов) и каким-либо свободным портом. bind() используется для связи сокета с определенным сетевым интерфейсом и номером порта:
HOST = '127.0.0.1'  # Standard loopback interface address (localhost)
PORT = 65432        # Port to listen on (non-privileged ports are > 1023)
# На серверной машине может быть несколько сетевых адаптеров, нам необходимо привязать созданный сокет к одному из них:
# server_sock.bind(('127.0.0.1', 53000))
# чтобы привязать сразу ко всем, можно использовать ''
# Если не указать хост или указать "0.0.0.0", сокет будет прослушивать все хосты. Если указать "127.0.0.1", то подключиться можно будет только с этого же компьютера.
# server_sock.bind((HOST, PORT))
# Вызов bind() требует указать не только IP адрес, но и порт, на котором сервер будет ожидать (слушать) подключения клиентов.
# Функция bind принимает массив, содержащий два элемента: хост и порт.
# Взаимодействие по сети происходит с помощью отправки пакетов, а TCP требует установления соединения, т.е. обмена между клиентом и сервером несколькими служебными пакетами, не содержащими реальных бизнес-данных.
# Каждое TCP соединение обладает состоянием. Их можно представить себе так:
# СОЕДИНЕНИЕ УСТАНАВЛИВАЕТСЯ -> УСТАНОВЛЕНО -> СОЕДИНЕНИЕ ЗАКРЫВАЕТСЯ

# Необходимо явно перевести сокет в состояние ожидания подключения, сообщив об этом операционной системе:
# Функция listen принимает в качестве аргумента максимальное число соединений, которые будут находиться в очереди соединений до вызова функции accept; она не ограничивает максимальное число активных соединений в целом.
server_sock.listen()

# Параметр backlog определяет размер очереди для установленных соединений.
# server_sock.listen(10)
# 10 - это размер очереди входящих подключений (backlog)
# Пока количество подключенных клиентов меньше, чем этот параметр, операционная система будет автоматически принимать входящие соединения на серверный сокет и помещать их в очередь.
# Как только количество установленных соединений в очереди достигнет значения backlog, новые соединения приниматься не будут.
# В зависимости от реализации, OC может явно отклонять новые подключения или просто их игнорировать, давая возможность им дождаться освобождения места в очереди.
# Функция listen принимает в качестве аргумента максимальное число соединений, которые будут находиться в очереди соединений до вызова функции accept;
# Функция не ограничивает максимальное число активных соединений в целом.

# Необходимо явно перевести сокет в состояние ожидания подключения, сообщив об этом операционной системе:
server_sock.listen(10)  # 10 - это размер очереди входящих подключений (backlog)
# После этого вызова операционная система готова принимать подключения от клиентов на этом сокете.

# Когда клиент подключается, сервер вызывает accept(), чтобы принять или завершить соединение.

with socket.socket(socket.AF_INET, socket.SOCK_STREAM, proto=0) as s:
    s.bind((HOST, PORT))
    s.listen()
    # Принимаем соединения с помощью функции accept.
    # Она ждёт появление входящего соединения и возвращает связанный с ним сокет и адрес подключившегося.
    # Адрес - массив, состоящий из IP-адреса и порта.
    conn, addr = s.accept()

# В объекте conn находится сокет, через который мы можем обмениваться данными с клиентом.
# В addr[0] - IP-адрес подключившегося клиента.
# Чтобы получить следующего клиента, нужно вызвать функцию accept еще раз, при этом необязательно закрывать соединение с предыдущим клиентом: соединений может быть условно неограниченное количество.

with conn:
    print('Connected by: ', addr)
    print('IP-адрес: ', addr[0])
    print('TCP порт: ', addr[1])

# После этого вызова операционная система готова принимать подключения от клиентов на этом сокете
server_sock.close()

# Подключиться к серверу можно с использованием консольной утилиты telnet, предназначенной для текстового обмена информацией поверх протокола TCP:
# telnet 127.0.0.1 65432
# telnet 127.0.0.1 65432
# Trying 127.0.0.1...
# Connected to 127.0.0.1.
# Escape character is '^]'.
# Connection closed by foreign host.
# Каждый TCP сокет определяется двумя парами чисел: (локальный IP адрес, локальный порт) и (удаленный IP адрес, удаленный порт):
#
# Connected by:  ('127.0.0.1', 39154)
# IP-адрес:  127.0.0.1
# TCP порт:  39154

